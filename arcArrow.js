// Generated by CoffeeScript 1.7.1

/*!
Copyright (c) 2002-2015 "Neo Technology,"
Network Engine for Objects in Lund AB [http://neotechnology.com]

This file is part of Neo4j.

Neo4j is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

(function() {
  'use strict';
  neo.utils.arcArrow = (function() {
    function arcArrow(startRadius, endRadius, endCentre, deflection, arrowWidth, headWidth, headLength, captionLayout) {
      var angleTangent, arcRadius, c1, c2, coord, cx, cy, deflectionRadians, endAngle, endAttach, endNormal, endOverlayCorner, endTangent, g1, g2, headRadius, homotheticCenter, intersectWithOtherCircle, midShaftAngle, negativeSweep, positiveSweep, radiusRatio, shaftRadius, square, startAngle, startAttach, startTangent, sweepAngle;
      this.deflection = deflection;
      square = function(l) {
        return l * l;
      };
      deflectionRadians = deflection * Math.PI / 180;
      startAttach = {
        x: Math.cos(deflectionRadians) * startRadius,
        y: Math.sin(deflectionRadians) * startRadius
      };
      radiusRatio = startRadius / (endRadius + headLength);
      homotheticCenter = -endCentre * radiusRatio / (1 - radiusRatio);
      intersectWithOtherCircle = function(fixedPoint, radius, xCenter, polarity) {
        var A, B, C, gradient, hc, intersection;
        gradient = fixedPoint.y / (fixedPoint.x - homotheticCenter);
        hc = fixedPoint.y - gradient * fixedPoint.x;
        A = 1 + square(gradient);
        B = 2 * (gradient * hc - xCenter);
        C = square(hc) + square(xCenter) - square(radius);
        intersection = {
          x: (-B + polarity * Math.sqrt(square(B) - 4 * A * C)) / (2 * A)
        };
        intersection.y = (intersection.x - homotheticCenter) * gradient;
        return intersection;
      };
      endAttach = intersectWithOtherCircle(startAttach, endRadius + headLength, endCentre, -1);
      g1 = -startAttach.x / startAttach.y;
      c1 = startAttach.y + (square(startAttach.x) / startAttach.y);
      g2 = -(endAttach.x - endCentre) / endAttach.y;
      c2 = endAttach.y + (endAttach.x - endCentre) * endAttach.x / endAttach.y;
      cx = (c1 - c2) / (g2 - g1);
      cy = g1 * cx + c1;
      arcRadius = Math.sqrt(square(cx - startAttach.x) + square(cy - startAttach.y));
      startAngle = Math.atan2(startAttach.x - cx, cy - startAttach.y);
      endAngle = Math.atan2(endAttach.x - cx, cy - endAttach.y);
      sweepAngle = endAngle - startAngle;
      if (this.deflection > 0) {
        sweepAngle = 2 * Math.PI - sweepAngle;
      }
      this.shaftLength = sweepAngle * arcRadius;
      if (startAngle > endAngle) {
        this.shaftLength = 0;
      }
      midShaftAngle = (startAngle + endAngle) / 2;
      if (this.deflection > 0) {
        midShaftAngle += Math.PI;
      }
      this.midShaftPoint = {
        x: cx + arcRadius * Math.sin(midShaftAngle),
        y: cy - arcRadius * Math.cos(midShaftAngle)
      };
      startTangent = function(dr) {
        var dx, dy;
        dx = (dr < 0 ? 1 : -1) * Math.sqrt(square(dr) / (1 + square(g1)));
        dy = g1 * dx;
        return {
          x: startAttach.x + dx,
          y: startAttach.y + dy
        };
      };
      endTangent = function(dr) {
        var dx, dy;
        dx = (dr < 0 ? -1 : 1) * Math.sqrt(square(dr) / (1 + square(g2)));
        dy = g2 * dx;
        return {
          x: endAttach.x + dx,
          y: endAttach.y + dy
        };
      };
      angleTangent = function(angle, dr) {
        return {
          x: cx + (arcRadius + dr) * Math.sin(angle),
          y: cy - (arcRadius + dr) * Math.cos(angle)
        };
      };
      endNormal = function(dc) {
        var dx, dy;
        dx = (dc < 0 ? -1 : 1) * Math.sqrt(square(dc) / (1 + square(1 / g2)));
        dy = dx / g2;
        return {
          x: endAttach.x + dx,
          y: endAttach.y - dy
        };
      };
      endOverlayCorner = function(dr, dc) {
        var arrowTip, shoulder;
        shoulder = endTangent(dr);
        arrowTip = endNormal(dc);
        return {
          x: shoulder.x + arrowTip.x - endAttach.x,
          y: shoulder.y + arrowTip.y - endAttach.y
        };
      };
      coord = function(point) {
        return "" + point.x + "," + point.y;
      };
      shaftRadius = arrowWidth / 2;
      headRadius = headWidth / 2;
      positiveSweep = startAttach.y > 0 ? 0 : 1;
      negativeSweep = startAttach.y < 0 ? 0 : 1;
      this.outline = function(shortCaptionLength) {
        var captionSweep, endBreak, startBreak;
        if (startAngle > endAngle) {
          return ['M', coord(endTangent(-headRadius)), 'L', coord(endNormal(headLength)), 'L', coord(endTangent(headRadius)), 'Z'].join(' ');
        }
        if (captionLayout === 'external') {
          captionSweep = shortCaptionLength / arcRadius;
          if (this.deflection > 0) {
            captionSweep *= -1;
          }
          startBreak = midShaftAngle - captionSweep / 2;
          endBreak = midShaftAngle + captionSweep / 2;
          return ['M', coord(startTangent(shaftRadius)), 'L', coord(startTangent(-shaftRadius)), 'A', arcRadius - shaftRadius, arcRadius - shaftRadius, 0, 0, positiveSweep, coord(angleTangent(startBreak, -shaftRadius)), 'L', coord(angleTangent(startBreak, shaftRadius)), 'A', arcRadius + shaftRadius, arcRadius + shaftRadius, 0, 0, negativeSweep, coord(startTangent(shaftRadius)), 'Z', 'M', coord(angleTangent(endBreak, shaftRadius)), 'L', coord(angleTangent(endBreak, -shaftRadius)), 'A', arcRadius - shaftRadius, arcRadius - shaftRadius, 0, 0, positiveSweep, coord(endTangent(-shaftRadius)), 'L', coord(endTangent(-headRadius)), 'L', coord(endNormal(headLength)), 'L', coord(endTangent(headRadius)), 'L', coord(endTangent(shaftRadius)), 'A', arcRadius + shaftRadius, arcRadius + shaftRadius, 0, 0, negativeSweep, coord(angleTangent(endBreak, shaftRadius))].join(' ');
        } else {
          return ['M', coord(startTangent(shaftRadius)), 'L', coord(startTangent(-shaftRadius)), 'A', arcRadius - shaftRadius, arcRadius - shaftRadius, 0, 0, positiveSweep, coord(endTangent(-shaftRadius)), 'L', coord(endTangent(-headRadius)), 'L', coord(endNormal(headLength)), 'L', coord(endTangent(headRadius)), 'L', coord(endTangent(shaftRadius)), 'A', arcRadius + shaftRadius, arcRadius + shaftRadius, 0, 0, negativeSweep, coord(startTangent(shaftRadius))].join(' ');
        }
      };
      this.overlay = function(minWidth) {
        var radius;
        radius = Math.max(minWidth / 2, shaftRadius);
        return ['M', coord(startTangent(radius)), 'L', coord(startTangent(-radius)), 'A', arcRadius - radius, arcRadius - radius, 0, 0, positiveSweep, coord(endTangent(-radius)), 'L', coord(endOverlayCorner(-radius, headLength)), 'L', coord(endOverlayCorner(radius, headLength)), 'L', coord(endTangent(radius)), 'A', arcRadius + radius, arcRadius + radius, 0, 0, negativeSweep, coord(startTangent(radius))].join(' ');
      };
    }

    return arcArrow;

  })();

}).call(this);
