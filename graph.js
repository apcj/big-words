// Generated by CoffeeScript 1.7.1
(function() {
  var dummyStatementToHelpIntelliJWithPreamble;

  dummyStatementToHelpIntelliJWithPreamble = true;

  (function() {
    return d3.selectAll('div.slide').each(function() {
      var addRelationship, arrowLayer, arrows, circleLayer, circles, connectNeighbours, connectReach, findNeighbours, force, i, maxDegree, modifications, nextRelationshipId, nodeCount, nodeRadius, nodes, parent, relationships, removeRelationship, size, svg, tick, tickCounter, update, viewBox, _i, _ref;
      size = 200;
      nodeCount = size * size / 500;
      nodeRadius = 7;
      connectReach = 200;
      maxDegree = 5;
      nodes = [];
      relationships = [];
      nextRelationshipId = 0;
      modifications = 10;
      for (i = _i = 0, _ref = nodeCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        nodes.push({
          id: i,
          x: size * (Math.random() * 2 - 1),
          y: size * (Math.random() * 2 - 1),
          radius: nodeRadius,
          degree: Math.floor(Math.random() * (maxDegree - 1)) + 1,
          neighbours: []
        });
      }
      findNeighbours = function(node) {
        var nx1, nx2, ny1, ny2, r;
        r = node.radius + connectReach;
        nx1 = node.x - r;
        nx2 = node.x + r;
        ny1 = node.y - r;
        ny2 = node.y + r;
        return function(quad, x1, y1, x2, y2) {
          var l, x, y;
          if (quad.point && quad.point !== node) {
            x = node.x - quad.point.x;
            y = node.y - quad.point.y;
            l = Math.sqrt(x * x + y * y);
            r = node.radius + connectReach + quad.point.radius;
            if (l < r) {
              node.neighbours.push({
                distance: l,
                node: quad.point
              });
            }
          }
          return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        };
      };
      connectNeighbours = function() {
        var connections, neighbour, node, q, _j, _k, _len, _len1, _results;
        q = d3.geom.quadtree(nodes);
        for (_j = 0, _len = nodes.length; _j < _len; _j++) {
          node = nodes[_j];
          q.visit(findNeighbours(node));
        }
        _results = [];
        for (_k = 0, _len1 = nodes.length; _k < _len1; _k++) {
          node = nodes[_k];
          node.neighbours.sort(function(a, b) {
            return a.distance - b.distance;
          });
          connections = Math.min(node.degree, node.neighbours.length);
          _results.push((function() {
            var _l, _ref1, _results1;
            _results1 = [];
            for (i = _l = 0, _ref1 = connections - 1; 0 <= _ref1 ? _l <= _ref1 : _l >= _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
              neighbour = node.neighbours[i];
              _results1.push(relationships.push({
                id: nextRelationshipId++,
                source: node,
                target: neighbour.node
              }));
            }
            return _results1;
          })());
        }
        return _results;
      };
      connectNeighbours();
      parent = d3.select(this);
      viewBox = function(size) {
        return [-size / 2, -size / 2, size, size].join(' ');
      };
      svg = parent.append('svg').attr('class', 'fill').attr('viewBox', viewBox(size * 2));
      arrowLayer = svg.append('g').attr('class', 'layer');
      circleLayer = svg.append('g').attr('class', 'layer');
      arrows = [];
      circles = [];
      update = function() {
        arrows = arrowLayer.selectAll('path.arrow').data(relationships, function(d) {
          return d.id;
        });
        arrows.enter().append('path').attr('class', 'arrow').attr('fill', 'none').attr('stroke', 'red').attr('stroke-width', 10).transition().duration(2000).attr('stroke', 'black').attr('stroke-width', 1);
        arrows.exit().remove();
        circles = circleLayer.selectAll('circle.node').data(nodes);
        return circles.enter().append('circle').attr('class', 'node').attr('r', function(d) {
          return d.radius;
        }).attr('fill', 'white').attr('stroke', 'black').attr('stroke-width', 1);
      };
      tickCounter = 0;
      tick = function() {
        arrows.attr('transform', function(d) {
          return 'translate(' + d.source.x + ' ' + d.source.y + ')';
        }).attr('d', function(d) {
          var dx, dy;
          dx = d.target.x - d.source.x;
          dy = d.target.y - d.source.y;
          return 'M 0 0 L ' + dx + ' ' + dy;
        });
        circles.attr('cx', function(d) {
          return d.x;
        }).attr('cy', function(d) {
          return d.y;
        });
        return tickCounter++;
      };
      setInterval(function() {
        d3.select('#fps').text(tickCounter);
        return tickCounter = 0;
      }, 1000);
      update();
      tick();
      force = d3.layout.force().nodes(nodes).links(relationships).charge(-10).gravity(0.01).linkDistance(40).on('tick', tick).start();
      addRelationship = function() {
        var node;
        i = Math.floor(Math.random() * nodeCount);
        node = nodes[i];
        if (node.degree < maxDegree - 1 && node.neighbours.length > node.degree) {
          relationships.push({
            id: nextRelationshipId++,
            source: node,
            target: node.neighbours[node.degree].node
          });
          return node.degree++;
        }
      };
      removeRelationship = function() {
        var node;
        i = Math.floor(Math.random() * nodeCount);
        node = nodes[i];
        if (node.degree > 1) {
          relationships = relationships.filter(function(d) {
            return !(d.source === node && d.target === node.neighbours[node.degree - 1].node);
          });
          return node.degree--;
        }
      };
      return setInterval(function() {
        var ignored, _j;
        for (ignored = _j = 1; 1 <= modifications ? _j <= modifications : _j >= modifications; ignored = 1 <= modifications ? ++_j : --_j) {
          addRelationship();
          removeRelationship();
        }
        update();
        return force.links(relationships).start();
      }, 100);
    });
  })();

}).call(this);
